---
created: 2025-02-03 16:23
category:
  - network
tags:
  - TIL
last_modified: 2025-02-03T17:12:00
---
## ⭐ 브라우저에서 URL을 입력하고 페이지가 완전히 렌더링될 때까지의 과정
### 🍪 1. URL 입력 & 네트워크 요청
- 사용자가 브라우저에 `https://example.com`을 입력 후 Enter -> 브라우저는 해당 URL을 처리하기 위한 네트워크 요청을 시작한다.
- 브라우저는 URL을 파싱(Parsing)하여 각 구성 요소를 분석한다.
- 네트워크 요청 전, 요청한 리소스가 캐시에 존재하는지 확인한다.
	- 있으면 네트워크 요청없이 리소스를 즉시 로드한다.
	- 없으면 네트워크를 통해 데이터를 요청한다(DNS 조회 -> TCP 연결 -> 요청 전송).

### 🍪 2. DNS 조회 (**D**omain **N**ame **S**ystem **Lookup**)
> URL의 도메인(`example.com`)을 IP 주소(ex: `93.184.216.34`)로 변환하는 과정이다.
1. **브라우저 캐시** 확인: 최근 방문한 사이트라면 브라우저 내부 DNS 캐시에 IP가 저장되어 있을 수 있다.
2. **운영체제(OS) 캐시** 확인: OS 레벨에서도 DNS 결과를 저장하여 빠르게 응답할 수 있다.
3. 로컬 네트워크 **(라우터) 확인**: 공유기(라우터)에도 캐시가 존재할 수 있다.
4. **ISP**(인터넷 서비스 제공업체) **확인**: ISP의 DNS 서버에서 IP 조회
5. 최종적으로 **루트 네임 서버에서 조회**: 캐시가 없다면, 최상위 네임 서버까지 요청하여 IP를 찾는다.

### 🍪 3. TCP 연결 & TLS 핸드셰이크
- 브라우저는 IP 주소를 확인 -> 해당 서버와 TCP 연결을 설정한다.
- 이 과정에서 3-Way-Handshake가 이루어진다.
	1. **클라이언트 -> 서버**: SYN 패킷 전송 (연결 요청)
	2. **서버 -> 클라이언트**: SYN-ACK 응답 (연결 요청 승인)
	3. **클라이언트 -> 서버**: ACK 응답 (연결 확정)

> 보안 연결(HTTPS)이라면, **TLS 핸드셰이크**를 수행하여 데이터 암호화를 설정한다.

### 🍪 4. HTTP 요청(Request) 전송
- TCP 연결이 완료되면, 브라우저는 HTTP 요청을 보낸다.
- 요청 헤더에는 브라우저 정보(User-Agent), 원하는 콘텐츠 타입(Accept) 등이 포함된다.
```
GET / HTTP/1.1
Host: example.com
User-Agent: Mozilla/5.0
Accept: text/html
```

### 🍪 5. 웹 서버의 응답(Response) & 리소스 다운로드
- 서버는 클라이언트의 요청을 받아 HTML, CSS, JS, 이미지 등의 리소스를 반환한다.
- HTML 문서가 먼저 전송되고, 브라우저는 HTML을 해석하며 필요한 추가 리소스를 요청한다.
- 브라우저가 CSS, JS, 이미지 등을 병렬로 다운로드하며 페이지를 구성한다.
```
HTTP/1.1 200 OK
Content-Type: text/html
```

### 🍪 6. 브라우저 렌더링 과정
> 웹 페이지가 화면에 나타나기 위해 브라우저는 다음 단계를 거친다.
1. **HTML 파싱 & DOM 트리 생성**
    - 브라우저는 HTML을 파싱하여 **DOM(Document Object Model) 트리**를 생성한다.
2. **CSS 파싱 & 스타일 계산 (CSSOM 생성)**
    - 브라우저는 CSS 파일을 파싱하여 **CSSOM(CSS Object Model) 트리**를 생성한다.
    - CSSOM을 기반으로 각 요소의 스타일을 계산한다.
3. **DOM + CSSOM 결합 → Render Tree 생성**
    - 브라우저는 **렌더 트리(Render Tree)** 를 만들어 화면에 표시할 요소들을 결정한다.
    - `display: none` 등의 요소는 렌더 트리에 포함되지 않는다.
4. **레이아웃(Layout) 계산**
    - 각 요소의 위치와 크기를 계산한다.
5. **페인트(Painting)**
    - 요소들을 실제 픽셀로 변환하여 화면에 그린다.
6. **컴포지팅(Compositing)**
    - 여러 레이어(layer)로 나누어 최종적으로 화면에 출력한다.

### 🍪 7. 페이지 인터랙션 가능 상태
- 화면이 표시되었더라도 JavaScript 실행, 추가적인 이미지 로딩 등의 작업이 남아 있을 수 있다.
- `DOMContentLoaded` 이벤트가 발생하면 **HTML과 CSS의 파싱이 완료**되었음을 의미한다.
- `load` 이벤트가 발생하면 **모든 리소스(CSS, JS, 이미지 등)가 완전히 로드**되었음을 의미한다.

---
### 🍪 (참고) 최적화를 위한 고려사항
- **DNS 프리페칭(DNS Prefetching)**: 미리 DNS를 조회하여 지연 최소화
- **HTTP/2, HTTP/3 사용**: 다중 요청을 병렬로 처리하여 속도 향상
- **CDN(Content Delivery Network) 활용**: 가까운 서버에서 콘텐츠 제공
- **리소스 압축(Gzip, Brotli) 적용**: 데이터 크기 감소
- **렌더링 최적화**:
    - CSS, JavaScript 비동기 로딩 (`async`, `defer`)
    - 이미지 지연 로딩 (`lazy loading`)
---
## 🧙‍♂️ 요약
- 사용자가 브라우저 주소창에 **URL 입력** -> 브라우저는 **URL을 파싱**한다.
- 브라우저는 **DNS Lookup**을 수행하여 **도메인에 해당하는 IP주소**를 요청 -> DNS는 IP주소를 찾아 응답한다.
- 브라우저는 **웹 서버와 TCP 연결** (3-way-handshake)
- 브라우저는 웹 서버에 **HTTP Request 전송** (GET, POST 등)
- 웹 서버는 요청을 처리한 후 **리소스를 Response**
- 브라우저는 HTML을 해석하여 DOM을 만들고, CSS를 적용한 후 JavaScript 실행 및 화면 렌더링을 수행한다.
---
## 📝 추가 학습
- 렌더링의 세부 과정
- TCP/IP
- 최적화 방법
---
> **참고사이트**
> - [브라우저 동작 원리 - 주소창에 URL 입력 시 일어나는 과정 (백엔드 편)](https://velog.io/@gyumin_2/%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80-%EB%8F%99%EC%9E%91-%EC%9B%90%EB%A6%AC-%EC%A3%BC%EC%86%8C%EC%B0%BD%EC%97%90-URL-%EC%9E%85%EB%A0%A5-%EC%8B%9C-%EC%9D%BC%EC%96%B4%EB%82%98%EB%8A%94-%EA%B3%BC%EC%A0%95-%EB%B0%B1%EC%97%94%EB%93%9C-%ED%8E%B8)
> - ChatGPT
