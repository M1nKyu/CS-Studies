---
created: 2025-01-08 17:50
category: 
tags:
  - TIL
---
## ⭐ 개념
#### 🍪 프로그램과 프로세스
- **프로그램**: 
	- 컴퓨터에서 실행할 수 있는 파일 (Static Program)
	- 파일이 메모리에 올라가 있지 않은 상태

- **프로세스**: 
	- 작업중인 프로그램 (Dynamic)
	- 메모리에 적재되고 CPU 자원을 할당받아 실행되고 있는 상태
---
#### 🍪 프로세스와 스레드의 차이 ([출처](https://www.geeksforgeeks.org/difference-between-process-and-thread/))

| **구분**       | **프로세스 (Process)**            | **스레드 (Thread)**                      |
| ------------ | ----------------------------- | ------------------------------------- |
| **정의**       | 실행 중인 프로그램.                   | 프로세스의 한 세그먼트.                         |
| **종료 시간**    | 종료하는 데 더 많은 시간이 소요됨.          | 종료하는 데 더 적은 시간이 소요됨.                  |
| **생성 시간**    | 생성하는 데 더 많은 시간이 소요됨.          | 생성하는 데 더 적은 시간이 소요됨.                  |
| **문맥 전환 시간** | 문맥 전환에 더 많은 시간이 소요됨.          | 문맥 전환에 더 적은 시간이 소요됨.                  |
| **통신 효율**    | 통신이 비교적 비효율적임.                | 통신이 더 효율적임.                           |
| **멀티태스킹 개념** | 멀티프로세스 기반.                    | 멀티프로그램 없이도 단일 프로세스에서 멀티스레드 가능.        |
| **메모리**      | 각 프로세스는 **독립된 메모리 공간**에서 실행됨. | 스레드는 **메모리를 공유**함.                    |
| **무게감**      | 프로세스는 스레드보다 무겁다.              | 스레드는 프로세스보다 가볍다.                      |
| **스위칭 방식**   | 운영체제의 인터페이스를 사용함.             | 운영체제를 호출하지 않아도 스위칭 가능.                |
| **차단 시 영향**  | 한 프로세스가 차단되어도 다른 프로세스는 영향 없음. | 한 사용자 수준 스레드가 차단되면 다른 스레드도 차단됨.       |
| **구조**       | **독립된 PCB, 스택, 주소 공간**을 가짐.   | **부모의 PCB**를 공유하고 **자체 TCB와 스택**만 가짐. |
| **변경 영향**    | 부모 프로세스의 변경이 자식 프로세스에 영향 없음.  | 메인 스레드의 변경이 다른 스레드에 영향을 줄 수 있음.       |
| **시스템 호출**   | 시스템 호출이 필요함.                  | API로 생성하며 시스템 호출이 필요 없음.              |
| **데이터 공유**   | **프로세스 간 데이터 공유를 하**지 않음.     | **스레드는 데이터 공유**가 가능함.                 |
- `PCB`: [프로세스 제어 블록](https://www.geeksforgeeks.org/process-table-and-process-control-block-pcb/)
---
#### 🍪 프로세스의 한계와 스레드
> 스레드는 프로세스의 비효율성을 보완하기 위해 생겨남.
###### 독립된 메모리 공간
- 프로세스의 **독립된 메모리** 공간 -> **프로세스간 통신이 느림**
- 스레드는 동일한 **프로세스 내에서 메모리 공유** -> 통신비용을 줄임

###### 비용이 큰 Context Switching
- `문맥전환(Context Switching)`은 운영체제가 개입하며 시간이 많이 소요
- 스레드는 프로세스 내에서 생성되고 전환 가능

###### 단일 작업 처리의 비효율성
- 프로세스는 **하나의 작업단위로 설계** -> **병렬처리 어려움**
- 스레드는 프로세스 내에서 병렬 처리 가능 -> 멀티태스킹 가능

###### 멀티프로세스 한계
- 멀티프로세스 환경에서는 각 프로세스가 독립적으로 실행 -> 자원 낭비
	- `멀티프로세스: 하나의 작업을 여러 개의 프로세스로 나누어 병렬로 처리하는 방식, 각 프로세스는 독립적으로 실행.`
- 스레드는 프로세스 내부에서 자원 공유 


> 결론적으로 스레드는 **프로세스의 자원을 공유**하면서도 **병렬 처리를 지원**하여 시스템의 성능을 극대화
---
#### 🍪 스레드
- **스레드**
	- **프로세스 내에서** **동시에 진행되는 작업 갈래, 흐름의 단위** 를 말한다

- 하나의 프로그램은 하나 이상의 프로세스를 가지고 있고, 하나의 프로세스는 반드시 하나 이상의 스레드를 갖는다.
	- 다수의 스레드는 프로그램 개발자가 직접 프로그래밍하여 위치 시켜주어야 한다.
---
## ⭐ 메모리
#### 🍪 프로세스 자원 구조
- 4가지의 메모리 영역으로 구성되어 할당
	1. **코드 영역**: 실행할 프로그램 코드(명령어)
	2. **데이터 영역**: 전역 변수, static 변수 등
	3. **스택 영역**: 함수 호출 시의 지역변수, 매개변수
	4. **힙 영역**: 동적으로 할당된 데이터


#### 🍪 스레드의 자원 공유
- 스레드는 **자신만의 스택 영역**을 가지며
- 나머지 **코드, 데이터, 힙** 영역은 다른 스레드와 **공유**한다.
---
## ⭐ 자원 공유
###### 프로세스 간 정보를 공유하는 방법
- **IPC (Inter-Process Communication)**: 
	- 서로 다른 프로세스 간에 데이터를 주고받을 수 있게 하는 기술로, 
		- 파이프, 메시지 큐, 소켓, 공유 메모리 등을 사용하여 프로세스 간 통신을 수행.
    
- **LPC (Local Procedure Communication)**: 
	- 동일한 시스템 내에서 프로세스 간에 직접적인 함수 호출을 통해 통신하는 방식으로,
		- 보통 운영체제에서 제공하는 메커니즘으로 빠르고 효율적인 프로세스 간 통신을 지원.

- **별도의 공유 메모리를 만들어 자원 공유**

> [!NOTE] 
> - 프로세스 자원 공유는 단순히 CPU 레지스터 교체뿐만이 아니라 RAM과 CPU 사이의 캐시 메모리까지 초기화되기 때문에 자원 부담이 크다는 단점이 있다. 
> - 그래서 다중 작업이 필요한경우 스레드를 이용하는 것이 훨씬 효율적이다.

---
## ⭐ 동시 실행의 원리
> 멀티태스킹이 CPU 프로세서가 프로그램을 한꺼번에 동시에 돌리는 것이 아니다.

- CPU 제품을 보면 *4코어 8쓰레드 CPU* 같은 것을 볼 수 있다.
	- *4코어*라는 것은 명령어를 메모리에서 뽑아 해석하고 실행하는 반도체 유닛이 4개가 있는 것
	- *4코어8쓰레드* 는 코어 하나가 스레드 두 개 이상을 동시에 실행 가능하다는 의미
	- 즉, **운영체제가 8개의 작업을 동시에 처리할 수 있다는 뜻** (하이퍼스레딩 기술)


> [!NOTE] 
> - 수십수백개의 프로세스들을 고작 8개의 논리적인 스레드도 어떻게 처리하는 것인가?
> 	- **[[병렬성(Parallelism)과 동시성(Concurrency)]]** 개념을 알아야 한다.

#### 🍪 병렬성
- 물리적인 개념

- 병렬성은 여러 작업을 실제로 동시에 처리하는 것.
- 여러 CPU 또는 코어를 사용하여 여러 작업을 병렬로 처리할 수 있다.

- 듀얼코어, 쿼드코어, 옥타코어 등등 이런 명칭이 붙는 멀티코어 프로세서가 달린 컴퓨터에서 할 수 있는 방식

#### 🍪 동시성
- 논리적인 개념

- 여러 작업이 동시에 진행되는 것처럼 보이게 하는 방식으로, 
	- 실제로는 하나의 프로세서에서 빠르게 전환하며 작업을 처리한다.

- 이때 작업들을 번갈아가면서 실행할때 작업들을 아주 잘게 나누어 아주 조금씩만 작업을 수행하고 다음 작업으로 넘어가는 식으로 동작한다.
	- 동시에 처리하는 것처럼 보이게 만들어, 사용자에게 더 빠른 반응성을 제공.

- **Context Switching**
	- 진행중인 작업들을 번갈아 바꾸는 것

###### 동시성이 필요한 이유
1. **하드웨어적 한계**
	- CPU에 수십수백개의 코어를 넣을 수 없다.
	- 수십수백개의 프로세스의 실행을 위해서는 동시성이 필요하다.

2. **논리적인 효율**
	- 4코어8스레드 환경에서 16개의 작업이 있다고 가정
		- 8개의 오래걸리는 작업과, 8개의 짧은 시간이 걸리는 작업이 있을 때,
			- 오래걸리는 작업들이 먼저 처리되기 시작한다면, 짧은 시간이 걸리는 작업이 오래걸리는 작업을 기다려야 하는 비효율 발생.\
	
	- 이를 극복하기 위해, 작업을 잘게 나눠 번갈아가며 처리하는 동시성 개념이 필요하다.

> 따라서 스레드를 적절히 병렬성과 동시성을 섞어 돌린다.
---
## 🧙‍♂️ 요약

- **프로세스**
	- 실행중인 프로그램
	- 서로 다른 메모리 공간에서 실행

- **스레드**
	- 특정 프로세스의 한 세그먼트 (실행 흐름의 단위)
	- 동일한 프로세스의 스레드는 공유 메모리 공간에서 실행

- **프로그램과 프로세스**: 프로그램은 실행 가능한 파일, 프로세스는 실행 중인 프로그램으로 메모리에 적재되어 CPU 자원을 할당받아 실행됨.
- **프로세스와 스레드**: 프로세스는 독립된 메모리 공간에서 실행, 스레드는 메모리를 공유하며 프로세스 내에서 실행되는 작업 단위.
- **프로세스의 한계와 스레드**: 스레드는 프로세스의 비효율성을 보완하고, 자원 공유 및 병렬 처리를 지원하여 성능을 극대화.
- **자원 공유**: 프로세스 간 데이터 공유는 IPC, 동일 시스템 내 프로세스 간 통신은 LPC를 사용.
- **병렬성 vs 동시성**: 병렬성은 여러 작업을 실제로 동시에 처리, 동시성은 작업을 빠르게 전환하여 동시에 진행되는 것처럼 보이게 함.
- **동시성의 필요성**: 하드웨어적 한계와 논리적 효율을 위해 동시성 개념을 사용, 병렬성과 동시성을 적절히 섞어 활용함.


| **구분**     | **프로세스 (Process)**            | **스레드 (Thread)**                      |
| ---------- | ----------------------------- | ------------------------------------- |
| **정의**     | 실행 중인 프로그램.                   | 프로세스의 한 세그먼트.                         |
| **메모리**    | 각 프로세스는 **독립된 메모리 공간**에서 실행됨. | 스레드는 **메모리를 공유**함.                    |
| **구조**     | **독립된 PCB, 스택, 주소 공간**을 가짐.   | **부모의 PCB**를 공유하고 **자체 TCB와 스택**만 가짐. |
| **데이터 공유** | **프로세스 간 데이터 공유를 하**지 않음.     | **스레드는 데이터 공유**가 가능함.                 |

---
> [!info] 참고 사이트
> [01](https://velog.io/@aeong98/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9COS-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%99%80-%EC%8A%A4%EB%A0%88%EB%93%9C)
> [02](https://inpa.tistory.com/entry/%F0%9F%91%A9%E2%80%8D%F0%9F%92%BB-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%E2%9A%94%EF%B8%8F-%EC%93%B0%EB%A0%88%EB%93%9C-%EC%B0%A8%EC%9D%B4)
