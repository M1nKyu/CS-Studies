---
created: 2025-02-09 15:22
category:
  - jpa
  - spring
tags:
  - TIL
last_modified: 2025-02-09T16:40:00
---
## ⭐ JPA 1차 캐시와 2차 캐시
### 🍪 1차 캐시 (Persistence Context Cache)
- [[영속성 컨텍스트 (JPA)|영속성 컨텍스트(Persistence Context)]] 내부에 존재하는 캐시이다.
- 트랜잭션 범위에서만 동작하며, 트랜잭션이 끝나면 삭제된다.
- EntityManager가 생성될 때 항상 1차 캐시가 생성되며, EntityManager가 종료될 때 함께 종료된다.
- 1차 캐시는 JPA에 기본적으로 활성화되어 있으며, 별도의 설정이 필요하지 않다.
#### 🍬 동작 방식
1. `em.find()`또는 `em.persist()`를 호출하면, 해당 엔티티는 1차 캐시에 저장된다.
2. 엔티티를 조회할 때 먼저 1차 캐시에서 찾는다.
3. 1차 캐시에 없다면 데이터베이스에서 조회하여 1차 캐시에 저장한 후 반환한다.
4. 이후 같은 엔티티를 조회할 때 데이터베이스 접근없이 1차 캐시에서 바로 반환한다.

#### 🍬 1차 캐시의 한계
- 트랜잭션이 종료되면 캐시도 사라진다 -> 다른 트랜잭션에서 재사용할 수 없다.
- 분산 환경이나 여러 트랜잭션에서 공유가 필요할 때도 공유할 수 없다.
> 이런 글로벌한 문제를 해결하기 위해 2차 캐시를 사용할 수 있다.
---
### 🍪 2차 캐시 (Second Level Cache)
- 애플리케이션 전체에서 공유하는 캐시이다.
- EntityMagerFactory 단위에서 관리된다.
	- 여러 트랜잭션과 EntityManager 간에 데이터를 공유할 수 있다.
- 애플리케이션이 종료되기 전까지 유지될 수 있다.
- 기본적으로 비활성화되어 있으며, 필요한 경우 설정을 통해 활성화해야 한다.
#### 🍬 특징
- 동시성을 고려한 설계가 필요하다.
- 캐시 적용 범위를 세밀하게 설정할 수 있다.
- 데이터 변경 시 캐시 동기화 전략이 필요하다.
- 자주 변경되는 데이터는 부적합하다.

#### 🍬 동작 방식
1. `em.find()`를 호출하면, 먼저 1차 캐시에서 Entity를 찾아본다.
2. 존재하지 않으면 2차 캐시에서 Entity를 찾아본다.
3. 2차캐시에서 데이터가 존재한다면 Entity 복사본을 반환합니다.
4. 2차캐시에도 데이터가 존재하지 않는다면 DB를 조회하여 2차캐시에 저장하고 반환합니다.

#### 🍬 복사본을 반환하는 이유
- 2차 캐시는 동시성을 극대화하기 위해 캐시한 객체를 직접 반환하지 않고 복사본을 만들어 반환한다.
- 만약 캐시한 객체를 그대로 반환하면 여러 곳에서 같은 객체를 동시에 수정하는 문제가 발생한다.
- 위 문제를 해결하기 위해 객체에 Lock을 걸어두는 방식도 있지만, 이는 성능 저하가 발생할 수 있다.
	- 락 획득(LOCK ACQUIRE)과 해제(LOCK RELEASE) -> 쓰레드 간 조율 필요
	- 경합(Contention) 증가 -> 여러 쓰레드가 같은 자원을 사용하려고 대기하는 시간 증가
	- 데드락(Deadlock) 가능성 -> 락을 잘못 사용하면 시스템이 멈출 수 있음
	- 확장성 저하 -> 동시에 많은 요청이 들어오면 성능 저하
- 락을 사용하면 동시성은 낮아지고(동시처리가 어려워짐), 성능이 저하될 수 있다.
	- 이에 비해, 객체를 복사하는 비용은 저렴하다.

> `동시성`: 여러 개의 작업(쓰레드, 요청 등)이 같은 리소스(데이터, 메모리, DB 등)에 동시에 접근할 수 있는 상태
> `동시성을 극대화 한다`: 여러 작업이 같은 자원에 동시에 접근할 수 있도록 하면서도, 데이터 정합성과 성능을 최적화하는 것

#### 🍬 구현체
> 2차 캐시는 JPA 자체에는 없고 구현체에서 제공한다.
- EhCache: 가장 많이 사용된다.
- Infinispan: 클러스터링 환경에 적합하다.
- Redis: 분산 캐시로 활용 가능하다.
---
### 🍪 1차 캐시와 2차 캐시 비교

| 구분       | 1차 캐시                           | 2차 캐시                                    |
| -------- | ------------------------------- | ---------------------------------------- |
| 저장 위치    | `EntityManager` 내부 (영속성 컨텍스트)   | `EntityManagerFactory` 내부 (애플리케이션 전체 공유) |
| 범위       | 트랜잭션 단위                         | 애플리케이션 단위                                |
| 생명주기     | 트랜잭션 종료 시 삭제                    | 애플리케이션 종료 전까지 유지 가능                      |
| 공유 여부    | 불가능 (각 `EntityManager`마다 개별 관리) | 가능 (모든 `EntityManager`에서 공유)             |
| 설정 필요 여부 | 자동 적용 (JPA 기본 기능)               | 별도 설정 필요 (`@Cacheable`, Hibernate 설정 등)  |
| 성능향상 대상  | 트랜잭션 내 반복 조회                    | 애플리케이션 전체 반복 조회                          |


---
### 🍪 Hibernate 2차 캐시보다 Spring 캐시 사용을 권장하는 이유
> [출처](https://www.inflearn.com/community/questions/33629/%EA%B0%95%EC%9D%98%EC%97%90%EB%8A%94-%EC%97%86%EB%8A%94-%EB%82%B4%EC%9A%A9%EC%9D%B4%EC%A7%80%EB%A7%8C-cache-%EA%B4%80%EB%A0%A8%ED%95%B4%EC%84%9C-%EC%A7%88%EB%AC%B8%EC%9D%B4-%EC%9E%88%EC%8A%B5%EB%8B%88%EB%8B%A4)
#### 🍬 1. 설정의 복잡성
- Hibernate 2차 캐시는 설정이 복잡하고, 지원하는 캐시 라이브러리도 제한적이다.
- 반면 Spring 캐시 기능은 다양한 라이브러리를 지원하며 설정이 상대적으로 간단하다.
#### 🍬 2. 서비스 계층에서의 활용성
- 실무에서는 서비스 계층에서 외부 API 호출, 여러 엔티티 조회, DTO 변환 등의 복잡한 로직을 수행한다.
- Hibernate 2차 캐시는 엔티티 조회(쿼리 포함)만 캐시할 수 있어 활용 범위가 제한된다.
- Spring 캐시는 DTO 결과를 캐싱할 수 있어, API 응답 성능을 더욱 효과적으로 개선할 수 있다.
#### 🍬 3. 캐시 라이브러리 지원
- Spring은 Redis, Ehcache, Caffeine, Guava Cache 등 다양한 캐시 라이브러리를 지원한다.
- Hibernate 2차 캐시는 지원하는 캐시 라이브러리가 상대적으로 적다.

#### 🍬 결론은
- Hibernate 2차 캐시는 엔티티 단위의 조회 캐시에만 국한되어 실무에서 활용성이 떨어진다.
- Spring의 캐시 기능을 활용하여 DTO 결과를 캐싱하는 것이 실무에서 더 효과적이다.
- Spring은 다양한 캐시 라이브러리를 지원하여 유지보수성과 확장성이 뛰어나다.
---
## 🧙‍♂️ 요약
- 1차 캐시
	- 영속성 컨텍스트 내부에 존재하는 캐시이다.
	- JPA 기본 활성화이며, 별도의 설정이 필요없다.
	- 동작: 조회 시 1차 캐시 -> 없으면 DB 조회 후 1차 캐시에 저장
	- 한계: 트랜잭션 종료 시 캐시 삭제 -> 다른 트랜잭션에서 재사용 불가

- 2차 캐시
	- 애플리케이션 전체에서 공유되는 캐시이다.
	- 여러 트랜잭션과 EntityManager간 데이터를 공유할 수 있다.
	- 기본적으로 비활성화되어 있어 설정이 필요하다.
	- 동작: 1차 캐시 확인 -> 없으면 2차 캐시 확인 -> 없으면 DB 조회 후 2차 캐시에 저장
	- 객체의 복사본을 반환한다 -> 동시성 극대화
	- 자주 변경되는 데이터에 부적합하다.

- Hibernate 2차 캐시보다 Spring 캐시를 권장하는 이유
	- Hibernate 2차 캐시는 엔티티 조회 캐시로만 한정되어 활용성이 낮다.
	- Spring 캐시를 사용하면 DTO 캐싱이 가능하여 성능 최적화에 더 효과적이다.
	- Spring 캐시는 다양한 캐시 라이브러리를 지원하여 유지보수성과 확장성이 뛰어나다.

---
> **참고사이트**
> - [01](https://devbksheen.tistory.com/entry/JPA-1%EC%B0%A8-%EC%BA%90%EC%8B%9C%EC%99%80-2%EC%B0%A8-%EC%BA%90%EC%8B%9C-%EC%86%8C%EA%B0%9C)
> - [02](https://blog.msg-team.com/jpa-1%EC%B0%A8-%EC%BA%90%EC%8B%9C%EC%99%80-2%EC%B0%A8-%EC%BA%90%EC%8B%9C-657ef1bedc66)
> - [03-하이버네이트 2차 캐시보다 스프링 지원 캐시 권장 이유](https://www.inflearn.com/community/questions/33629/%EA%B0%95%EC%9D%98%EC%97%90%EB%8A%94-%EC%97%86%EB%8A%94-%EB%82%B4%EC%9A%A9%EC%9D%B4%EC%A7%80%EB%A7%8C-cache-%EA%B4%80%EB%A0%A8%ED%95%B4%EC%84%9C-%EC%A7%88%EB%AC%B8%EC%9D%B4-%EC%9E%88%EC%8A%B5%EB%8B%88%EB%8B%A4)
> - [04](https://vlogue.inblog.ai/36939)
