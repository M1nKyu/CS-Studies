---
created: 2025-01-14 18:38
category:
  - database
tags:
  - TIL
---
## ⭐데드락, 트랜잭션 격리 레벨, 트랜잭션 락
#### 🍪 트랜잭션(Transaction) 이란?
- 더이상 분할이 불가능한 업무처리의 단위
- **한꺼번에 수행되어야 할 일련의 연산**의 모음

###### 🍬 예시 (송금을 하는 경우)
- 계좌이체는
	- **인출**과 **입금** 두 과정으로 이루어 진다.
	- 만약 인출은 성공했지만, 입금이 실패하는 경우가 생겨선 안된다.
> 따라서 두 과정은 **동시에 성공**하거나 **동시에 실패**해야 한다. 
---
#### 🍪 트랜잭션의 특징 (ACID)
###### 🍬 원자성(Atomicity)
- 트랜잭션이 데이터베이스에 **모두 반영되던가, 아니면 전혀 반영되지 않아야** 한다

###### 🍬 일관성(Consistency)
- 트랜잭션이 진행되는 동안에 데이터베이스가 변경 되더라도   
	- 업데이트된 데이터베이스로 트랜잭션이 진행되는것이 아니라, **처음에 트랜잭션을 진행 하기 위해 참조한 데이터베이스로 진행**

###### 🍬 독립성(Isolation)
- 어떤 하나의 트랜잭션이라도, **다른 트랜잭션의 연산에 끼어들 수 없다**.

###### 🍬 영구성(Durability)
- 트랜잭션이 성공적으로 완료됬을 경우, 결과는 **영구적으로 반영**되어야 한다.
---
#### 🍪 트랜잭션 연산
###### 🍬 Commit
- 모든 작업을 처리하겠다고 확정하는 명령어
- 처리 과정을 DB에 영구 저장
- `Commit`이 수행되면 하나의 트랜잭션 과정이 종료되는 것
- `Commit`을 수행하면 이전 데이터가 완전히 반영되어 `UPDATE`된다.

###### 🍬 Rollback
- 트랜잭션 처리 과정에서 발생한 **변경사항을 취소하는 명령어**
- 트랜잭션이 시작되기 이전 상태로 돌아간다.
	- 마지막 `Commit`을 완료한 시점으로 돌아가는 것과 같다.
	- **Commit 하여 저장한 예전 상태를 복구하는 것**이다.
---
#### 🍪 데드락 (교착상태)
- **두 개 이상의 트랜잭션**이 서로 상대방이 점유하고 있는 자원을 기다리며 **무한 대기 상태**에 빠지는 상황
- A: 자원 1을 점유, 자원 2 기다림
- B: 자원 2를 점유, 자원 1 기다림

###### 🍬 발생 조건
> 한 시스템 내에서 다음 4가지 조건이 동시에 성립할 때 발생한다.

1. **상호 배제** (Mutual Exclusion)
	- 자원은 한 번에 한 트랜잭션만이 사용할 수 있다.
2. **점유 대기**
	- 이미 자원을 점유하고 있는 트랜잭션이 추가적인 자원을 기다리는 상황
3. **비선점**
	- 다른 트랜잭션이 점유한 자원은 사용이 끝날 때까지 강제로 뺏을 수 없다.
4. **순환 대기**
	- 트랜잭션들이 자원을 서로 기다리는 상태

###### 🍬 데드락 해결 방법
> 전략: **예방** / **회피** / **검출 및 회복** 

- 예방 방법: **4가지 발생 조건을 차단하여 예방**
	- 상호배제 차단: 모든 자원이 공유 가능하도록 설계
	- 점유 및 대기 차단: 트랜잭션이 자원을 모두 요청할 때 까지 대기
	- 비선점 차단: 트랜잭션이 자원을 강제로 뺏을 수 있도록 허용
	- 순환대기 차단: 자원을 요청하는 순서를 미리 정해둠

- 회피 방법: 교착 상태를 예상하여 안전한 상태에서만 자원 요청을 허용
	- **은행가 알고리즘**: 
		- 자원을 요청받았을 때 그 요청을 허용해도 시스템이 데드락에 빠지지 않는지 검증합니다. 이를 위해 각 트랜잭션이 요청할 수 있는 최대 자원의 수와 현재 보유한 자원의 수를 추적

- 검출 및 회복 방법
	- **검출**: 
		- 주기적으로 시스템 모니터링 
		- 자원 할당 그래프 사용
	- **회복**:
		1. **트랜잭션 롤백**
			- 데드락에 걸린 트랜잭션 중 하나를 롤백하여 자원 해제
		2. **트랜잭션 종료**
			- 데드락에 걸린 트랜잭션 강제 종료, 자원 반환
		3. **우선순위 기반 회복**
			- 트랜잭션 우선순위를 부여 -> 낮은 우선순위의 트랜잭션을 종료하여 자원 회수 
			- 희생자 선택, 기아 상태 고려 해야함

> 데드락이 발생할 때까지 기다려야 함 
> 롤백하거나 종료할 때 데이터 일관성에 문제 발생 가능

|전략|장점|단점|
|---|---|---|
|**예방**|데드락을 아예 발생시키지 않음|성능에 영향을 미칠 수 있음|
|**회피**|데드락 발생을 동적으로 회피|자원 관리가 복잡하고 성능에 부담을 줄 수 있음|
|**검출 및 회복**|데드락을 추적하여 복구 가능|데드락 발생 후 대기시간이 길어짐|


---
#### 🍪 락(Lock)
- 특정 작업을 수행하는 동안 **다른 트랜잭션의 접근으로부터 보호**하는 방법.

- **데이터의 일관성** 보장, 동시에 수행되는 **트랜잭션간 충돌 방지**를 위해 **자원(행, 테이블)을 잠그는 매커니즘**.

- 락을 통해 한 트랜잭션이 자원을 수정하는 동안 다른 트랜잭션은 그 자원을 변경할 수 없다.

- Lock은 트랜잭션이 Commit 되거나, Rollback 될 때 함께 Unlock된다.

###### 🍬 종류
1. **공유 락** (Shared Lock)
	- 데이터가 읽기 전용으로 잠겨있을 때 사용된다.
	- 여러 트랜잭션이 동시에 같은 데이터를 읽을 수 있지만, 쓰기 작업은 허용하지 않는다.
2. **배타 락** (Exclusive Lock)
	- 데이터가 수정 중일 때 사용된다.
	- 한 트랜잭션만이 데이터를 읽고 쓸 수 있게 해주며, 이 트랜잭션이 락을 해제할 때까지 다른 모든 트랜잭션의 접근을 차단한다.
3. 테이블 수준 락 (Table-level Lock)
	- 테이블 전체에 락을 걸어 다른 트랜잭션이 해당 테이블을 수정할 수 없게 한다.
4. 행 수준 락 (Row-level Lcok)
	- 특정 행에 대해서만 락을 걸 수 있다.
	- 더 세밀한 제어를 가능하게 하며 성능 저하를 줄일 수 있다.

###### 🍬 락의 종류에 따른 트랜잭션 성능
- **낮은 격리 수준**
	- 락을 적게 사용 -> 빠른 성능
	- 일관성에 문제 발생 가능
- **높은 격리 수준**
	- 락이 많이 사용 -> 성능 저하
	- 일관성 보장
---
#### 🍪 트랜잭션 격리 수준 (Isolation Level)
> 여러 트랜잭션이 동시에 처리될 때, 특정 트랜잭션이 다른 트랜잭션에서 변경하거나 조회하는 데이터를 볼 수 있게 허용할지 여부를 결정하는 것.

- 격리 수준이 높은 것부터
	- **SERIALIZABLE** > **REPEATABLE READ** > **READ COMMITTED** > **READ UNCOMMITED**

###### 🍬 SERIALIZABLE (가장 엄격)
- 트랜잭션이 완전히 직렬화된 것처럼 실행된다.
	- 다른 트랜잭션을 동시에 실행할 수 없다.
- 성능 측면에서 동시성이 가장 낮지만, 모든 문제를 방지할 수 있다.
- **Phantom Read 까지 방지**
- DB에서 거의 사용되지 않는다.
###### 🍬 REPEATABLE READ
- **한 트랜잭션 내에서 같은 쿼리**를 여러번 실행할 경우 언제나 **동일한 결과**.
- 트랜잭션마다 고유한 **트랜잭션 ID** 부여, 이 ID보다 **작은 트랜잭션 번호에서 변경한 데이터만 읽게** 된다. (MVCC 기법)
- 변경전 레코드를 백업(MySQL은 **Undo Log**에 저장) -> 변경 전/후 데이터 모두 존재 (MVCC)
- Undo Log가 계속 쌓이면 서버 처리 성능 저하 -> 주기적 삭제 필요
- 한 트랜잭션 내에서 동일한 결과를 보장하지만, 새로운 레코드가 추가되는 경우 부정합이 생길 수 있다.
- **Dirty Read, Non Repeatable Read 방지**
- **Phantom Read 발생** : 쓰기 잠금을 걸어서 방지 가능.

###### 🍬 READ COMMITTED
- 다른 트랜잭션이 커밋한 데이터만 읽을 수 있다.
- 대부분의 **RDB에서 기본적으로 사용**되는 격리 수준이다.
- 실제 테이블값이 아닌 **Undo 영역에 백업된 레코드**에서 가져옴
- **더러운 읽기는 방지**
- **비반복 읽기 발생** 
###### 🍬 READ UNCOMMITED (가장 낮은 격리)
- **더러운 읽기**, **비반복 읽기**, **팬텀 읽기** 모두 발생 가능하다.
- 데이터베이스 성능은 높지만 일관성, 정합성에 문제가 많다.

> 용어
>- `MVCC`: 다중 버전 병행 제어, 데이터의 여러 버전을 유지해 트랜잭션 간 충돌을 방지하는 기법.
>- `더러운 읽기(Dirty Read)`: 커밋되지 않은 데이터를 다른 트랜잭션이 읽는 현상.
>- `비반복 읽기(Non-Repeatable Read)`: 동일 트랜잭션 내에서 같은 데이터를 두 번 읽을 때 값이 달라지는 현상.
>- `팬텀 읽기(Phantom Read)`: 동일 트랜잭션 내에서 쿼리 결과에 새로운 행이 추가되거나 사라지는 현상.

---
## 🧙‍♂️ 요약


---
>**참고 사이트**
> - [01](https://velog.io/@goatyeonje/Database-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98-%EC%9E%A0%EA%B8%88-%EA%B2%A9%EB%A6%AC-%EA%B7%B8%EB%A6%AC%EA%B3%A0-%EB%8D%B0%EB%93%9C%EB%9D%BD)
> - [02](https://inpa.tistory.com/entry/MYSQL-%F0%9F%93%9A-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98Transaction-%EC%9D%B4%EB%9E%80-%F0%9F%92%AF-%EC%A0%95%EB%A6%AC)
> - [03](https://jwprogramming.tistory.com/12)
> - [04](https://wookjongbackend.tistory.com/39)
> - [트랜잭션 격리 수준](https://mangkyu.tistory.com/299)
